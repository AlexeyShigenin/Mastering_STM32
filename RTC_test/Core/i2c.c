/**
	******************************************************************************
	* @file			i2c.c
	* @brief		Функции для работы с I2C
	* @author		Алексей Шигенин	
	******************************************************************************
	*/
																																	
#include "i2c.h"
#include "delay.h"
#include "stm32f10x.h"

/**
	******************************************************************************
	* @brief		Инициализация интерфейса I2C1
	* @param		None
	* @retval		None
	******************************************************************************
	*/
void i2cInit(void){
	// Включение тактирования I2C1 и GPIOB
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN | RCC_APB2ENR_AFIOEN;

	// Ремаппинг I2C1 на PB8(SCL), PB9(SDA)
	AFIO->MAPR |= AFIO_MAPR_I2C1_REMAP;
	
	// Ќастройка PB8 (SCL) и PB9 (SDA) как альтернативная функция с открытым стоком
	GPIOB->CRH &= ~(GPIO_CRH_CNF8 | GPIO_CRH_MODE8 | GPIO_CRH_CNF9 | GPIO_CRH_MODE9);					// Сброс предыдущих настроек
	GPIOB->CRH |= GPIO_CRH_CNF8_0 |GPIO_CRH_CNF8_1 | GPIO_CRH_MODE8_0 | GPIO_CRH_MODE8_1 |		// SCL: AF Open-drain, 50MHz
								GPIO_CRH_CNF9_0 |GPIO_CRH_CNF9_1 | GPIO_CRH_MODE9_0 | GPIO_CRH_MODE9_1;			// SDA: AF Open-drain, 50MHz
	
	// Сброс I2C1
	RCC->APB1RSTR |= RCC_APB1RSTR_I2C1RST;
	RCC->APB1RSTR &= ~RCC_APB1RSTR_I2C1RST;
	
	// ENDUAL – ENable DUAL addressing mode (Включение режима двойной адресации)
	// 1 – включает ответ на два адреса (основной из OAR1 и дополнительный из ADD2), 0 - отключает
	I2C1->OAR2 &=~ I2C_OAR2_ENDUAL; // Отключаем режим двойной адресации
	
	// ADD2 – Dual addressing mode slave address - адрес слейва в режиме двойной адресации
	// Задаёт второй 7-битный адрес для режима двойной адресации
	I2C1->OAR2 = I2C_OAR2_ADD2;
	
	// ENGC – ENable General Call (разрешение широковещательного вызова)
	// 1 – отвечает на широковещательный адрес (0x00), 0 - не отвечает
	I2C1->CR1 &=~ I2C_CR1_ENGC; // Выключение ответа на широковещательный вызов
	
	// NOSTRETCH (Clock stretching disable) - запрет растяжения тактового сигнала
	// 1 – отключает растяжение тактового сигнала (SCL) в режиме мастера при ожидании данных, 0 - включает
	I2C1->CR1 &=~ I2C_CR1_NOSTRETCH; //Включаем Clock stretching
		
	I2C1->CR1 &=~ I2C_CR1_PE;// Отключаем I2C перед настройкой
	
	// Максимальное время нарастания (для стандартного режима)
	// TRISE (Time RISE maximum) = APB1_FREQ_MHz + 1 = 36 + 1 = 37
	// Задаёт максимальное время нарастания сигнала SCL (в тактах APB1)
	// Для стандартного режима: TRISE >= (частота_APB1_в_МГц + 1).
	// Для быстрого режима: TRISE >= ((частота_APB1_в_МГц * 300 нс) + 1)
	I2C1->TRISE = 37;
	
	// Настройка частоты (при 36 MHz APB1)
	I2C1->CR2 = 36;  // Задаёт частоту тактового сигнала APB1 (в МГц) для расчётов таймингов. Допустимые значения: 2–50 МГц.
	
	// CCR – (Clock Control Register) задаёт делитель частоты для генерации тактового сигнала SCL. Формула зависит от режима (стандартный/быстрый)
	// CCR = APB1_FREQ / (2 * I2C_FREQ)
	// Для 100 kHz: CCR = 36,000,000 / (2 * 100,000) = 180
	I2C1->CCR = 180; // CCR = 180

	// POS – acknowledge POSition (0 – ACK отправляется после текущего байта; 1 – ACK отправляется после следующего байта)
	I2C1->CR1 &= ~I2C_CR1_POS;
	// ACK – ACKnowledge enable (1 – мастер/слейв отправляет ACK после принятого байта. 0 – отправляется NACK)
	I2C1->CR1 |= I2C_CR1_ACK;

	// Включаем I2C
	I2C1->CR1 |= I2C_CR1_PE;
	
	// Задержка для стабилизации
    delayDWT_ms(10);
}

/**
	******************************************************************************
	* @brief		Запись байта по указанному адресу
	* @param		data	Передаваемые данные
	* @param		addr	Адрес устройства для передачи  (7-битный)
	* @retval		None
	******************************************************************************
	*/
void i2cWriteByte(uint8_t addr, uint8_t data) {
	// Генерация условия START
	i2cStart();
  
	i2cWrite((addr << 1) | I2C_REQUEST_WRITE); // Отправка адреса устройства, сдвинутого на 1 влево (если адрес 0x27, то будет 0x4E) в режиме записи
	// Ожидание флага ADDR
	// ADDR в SR1 – Address sent. Устанавливается в 1 после передачи/приёма адреса. Сбрасывается чтением SR1 и последующим чтением SR2
	uint32_t timeout = 100000;	// Переменная для исключения зависаний
	while(!(I2C1->SR1 & I2C_SR1_ADDR) && timeout--) {
		__NOP(); // Пустая операция для избежания оптимизации
		};
	if (timeout == 0) {
		// Обработка ошибки таймаута
	}
	// Сброс флага ADDR c выключением прерываний чтобы не нарушилась последовательность сброса ADDR
	// Сохраняем состояние регистра PRIMASK в переменную primask
	// __get_PRIMASK() возвращает 0, если прерывания разрешены, и 1, если запрещены
	uint32_t primask = __get_PRIMASK();
	__disable_irq();	// Выключение прерываний
	
	(void)I2C1->SR1;  // Чтение SR1 - первый шаг последовательности сброса ADDR
	(void)I2C1->SR2;  // Чтение SR2 - второй шаг последовательности сброса ADDR
	
	// Восстанавливаем состояние регистра PRIMASK из переменной primask
	// __set_PRIMASK(1) эквивалентно __disable_irq()
	// __set_PRIMASK(0) эквивалентно __enable_irq()
	__set_PRIMASK(primask);

	// Отправка данных(data);
	i2cWrite(data);
	// Ожидание завершения передачи
	// BTF в SR1 – ByteTransferFinished.
	//Устанавливается в 1 если байт передан и DR готов для следующего байта.
	// Сбрасывается чтением SR1, затем чтения/записи DR
	timeout = 100000;	// Переменная для исключения зависаний
	while (!(I2C1->SR1 & I2C_SR1_BTF) && timeout--) {
		__NOP(); // Пустая операция для избежания оптимизации
		};
	if (timeout == 0) {
		// Обработка ошибки таймаута
	}
	
	// Генерация условия STOP
	i2cStop();
	
	// Задержка для стабилизациии
    delayDWT_us(15);
}

/**
	******************************************************************************
	* @brief		Генерация условия START
	* @param		None
	* @retval		None
	******************************************************************************
	*/
void i2cStart(void) {
	// Установка в 1 программно генерирует условие START на шине. Сбрасывается аппаратно после передачи адреса
	I2C1->CR1 |= I2C_CR1_START;
	// Ожидание флага SB (StartBit) в регистре SR1 (StatusRegister1)
	// Устанавливается в 1 аппаратно после генерации условия START. Сбрасывается чтением SR1 с последующей записью в DR
	uint32_t timeout = 100000;	// Переменная для исключения зависаний
	while (!(I2C1->SR1 & I2C_SR1_SB) && timeout--){
	__NOP(); // Пустая операция для избежания оптимизации
		};
	if (timeout == 0) {
		// Обработка ошибки таймаута
	}
}

/**
	******************************************************************************
	* @brief		Генерация условия STOP
	* @param		None
	* @retval		None
	******************************************************************************
	*/
void i2cStop(void) {
	// Генерация STOP
	I2C1->CR1 |= I2C_CR1_STOP;
	// Ожидание завершения.
	// STOP в СR1 сбрасывается аппаратно при обнаружении STOP на шине, поэтому ожидаем сброса STOP в CR1
	uint32_t timeout = 100000;	// Переменная для исключения зависаний
	while ((I2C1->CR1 & I2C_CR1_STOP) && timeout--){
	__NOP(); // Пустая операция для избежания оптимизации
		};
	if (timeout == 0) {
		// Обработка ошибки таймаута
	}
}

/**
	******************************************************************************
	* @brief		Отправка байта данных
	* @param		data	Передаваемые данные
	* @retval		None
	******************************************************************************
	*/
void i2cWrite(uint8_t data) {
	// Запись данных в DR
	I2C1->DR = data;
	// Ожидание флага TXE (Transmit buffer Empty) - DR пуст и готов к приёму новых данных для передачи. TXE сбрасывается записью в DR
	uint32_t timeout = 100000;	// Переменная для исключения зависаний
	while (!(I2C1->SR1 & I2C_SR1_TXE) && timeout--) {
		__NOP(); // Пустая операция для избежания оптимизации
		};
	if (timeout == 0) {
		// Обработка ошибки таймаута
	}
}
