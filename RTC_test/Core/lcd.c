/**
	******************************************************************************
	* @file			lcd.c
	* @brief		Функции для работы с LCD 1602 по шине I2C (PCF8574T)
	*
	* LCD подключен через I2C расширитель портов PCF8574T.
  * Используется 4-битный режим передачи данных.
	******************************************************************************
	*/

#include "lcd.h"

/*******************************************************************************
	* @brief  Отправка полубайта (4 бита) на LCD
	* @param  data: данные (нижние 4 бита)
	* @param  rs: флаг RS (0 - команда, 1 - данные)
	* @retval None
	******************************************************************************
	*/
static void lcdSendNibble(uint8_t data, uint8_t rs) {
    
	// Извлекаем из data только младшие 4 бита
	// data & 0x0F = маска, оставляющая только биты 0-3
	uint8_t nibble = data & 0x0F;
	
	// Инициализируем переменную для формирования байта отправки
	// control будет содержать все управляющие биты для PCF8574T
	uint8_t control = 0;
    
	// Установка битов данных D4-D7 на основе ниббла
	// Проверяем каждый бит ниббла и устанавливаем соответствующий бит в control
	if (nibble & 0x01) control |= LCD_D4_PIN;
	if (nibble & 0x02) control |= LCD_D5_PIN;
	if (nibble & 0x04) control |= LCD_D6_PIN;
	if (nibble & 0x08) control |= LCD_D7_PIN;
    
	// Установка бита RS (Register Select)
	// RS = 0: отправляем команду (запись в регистр команд)
	// RS = 1: отправляем данные (запись в регистр данных)
	if (rs) control |= LCD_RS_PIN;
    
	// LCD_BL_PIN = 1 включает подсветку, 0 - выключает
	// Подсветка всегда включена
	control |= LCD_BL_PIN;
    
	// Последовательность стробирования (strobe)
	// Для записи данных на LCD необходимо:
	// 1. Установить бит E (Enable) в 1
	// 2. Выдержать паузу (не менее 450 нс)
	// 3. Установить бит E в 0
    
	// 1. Сначала выставляем на шину байт с установленным битом E
	// (добавляем бит E к остальным установленным битам)
	i2cWriteByte(LCD_ADDRESS, control | LCD_E_PIN);
	
	// 2. Пауза > 450 нс
	delayDWT_ms(1);
	
	// 3. Отправляем байт без бита E (устанавливаем E в 0)
	// Это создает спад импульса, по которому LCD защелкивает данные
	i2cWriteByte(LCD_ADDRESS, control);
	
	// Пауза для стабилизации
	delayDWT_ms(1);
}

/*******************************************************************************
  * @brief  Запись байта в 4-битном режиме
  * @param  data: данные для записи
  * @param  rs: флаг RS
  * @retval None
	******************************************************************************
	*/
static void lcdWrite4Bits(uint8_t data, uint8_t rs) {
    // Отправка старшего ниббла
    lcdSendNibble(data >> 4, rs);
    // Отправка младшего ниббла
    lcdSendNibble(data & 0x0F, rs);
}

/*******************************************************************************
  * @brief  Отправка команды на LCD
  * @param  cmd: команда
  * @retval None
	******************************************************************************
	*/
void lcdSendCommand(uint8_t cmd) {
    lcdWrite4Bits(cmd, 0);
    if (cmd == LCD_CLEAR_DISPLAY || cmd == LCD_RETURN_HOME) {
        delayDWT_ms(6);
    } else {
        delayDWT_ms(6);
		}
}

/*******************************************************************************
  * @brief  Отправка данных на LCD
  * @param  data: данные
  * @retval None
	******************************************************************************
	*/
void lcdSendData(uint8_t data) {
    lcdWrite4Bits(data, 1);
    delayDWT_ms(1);
}

/*******************************************************************************
  * @brief  Очистка дисплея
  * @param  None
  * @retval None
	******************************************************************************
	*/
void lcdClear(void) {
    lcdSendCommand(LCD_CLEAR_DISPLAY);
}

/*******************************************************************************
  * @brief  Установка позиции курсора
  * @param  row: строка (0 или 1)
  * @param  col: столбец (0-15)
  * @retval None
	******************************************************************************
	*/
void lcdSetCursor(uint8_t row, uint8_t col) {
    uint8_t address;
    
    // Адреса начала строк в DDRAM
    if (row == 0) {
        address = 0x00;
    } else {
        address = 0x40;
    }
    address += col;
    
    // Отправка команды установки адреса
    lcdSendCommand(LCD_SET_DDRAM_ADDR | address);
}

/*******************************************************************************
  * @brief  Вывод символа
  * @param  c: символ
  * @retval None
	******************************************************************************
	*/
void lcdPrintChar(char c) {
    lcdSendData(c);
}

/*******************************************************************************
  * @brief  Вывод строки
  * @param  str: указатель на строку
  * @retval None
	******************************************************************************
	*/
void lcdPrintString(const char* str) {
    while (*str) {
        lcdPrintChar(*str++);
    }
}

/*******************************************************************************
  * @brief  Инициализация LCD
  * @param  None
  * @retval None
	******************************************************************************
	*/
void lcdInit(void) {
	// Задержка для стабилизации питания LCD
	delayDWT_ms(40);
    
	// Начальная последовательность инициализации.
	// Перед включением 4-битного режима необходимо трижды
	// отправить команду установки 8-битного режима LCD_FUNCTION_SET | LCD_8BIT_MODE.
	// После трехкратной отправки команды дисплей выравнивает
	// свой внутренний счетчик и начинает правильно интерпретировать поток.
	// Т.к. LCD_FUNCTION_SET | LCD_8BIT_MODE это 0x30 (0011 0000), а 
	// send_nibble отправляет только 4 младшие бита, то необходимо сдвинуть данные
	// на 4 разряда вправо, т.е. нужно отправить 0000 0011 (0x03)
	lcdSendNibble(0x03, 0);  // 1
	delayDWT_ms(6);
	lcdSendNibble(0x03, 0);  // 2
	delayDWT_ms(6);
	lcdSendNibble(0x03, 0);  // 3
	delayDWT_ms(6);

	// Переход в 4-битный режим
	// Аналогично команда LCD_FUNCTION_SET | LCD_8BIT_MODE это 0x20 (0010 0000)
	// соответственно, нужно сдвинуть на 4 разряда вправо, 0000 0010 (0x02)
	lcdSendNibble(0x02, 0);  // Старший ниббл команды 0x20
	delayDWT_ms(6);

	// Теперь можно отправлять команды в 4-х битном режиме.
    
	// Установка режима: 2 строки, 5x8 точек
	lcdSendCommand(LCD_FUNCTION_SET | LCD_4BIT_MODE | LCD_2LINE | LCD_5x8_DOTS);
    
	// Выключение дисплея
	lcdSendCommand(LCD_DISPLAY_CONTROL | LCD_DISPLAY_OFF);
    
	// Очистка дисплея
	lcdSendCommand(LCD_CLEAR_DISPLAY);
    
	// Установка режима ввода
	lcdSendCommand(LCD_ENTRY_MODE_SET | LCD_ENTRY_LEFT | LCD_ENTRY_SHIFT_OFF);
    
	// Включение дисплея с курсором
	lcdSendCommand(LCD_DISPLAY_CONTROL | LCD_DISPLAY_ON | LCD_CURSOR_OFF | LCD_BLINK_OFF);
    
	// Включение подсветки
	i2cWriteByte(LCD_ADDRESS, LCD_BL_PIN);
}

/*******************************************************************************
  * @brief  Обновление времени на дисплее
  * @param  time: указатель на структуру времени
  * @retval None
	******************************************************************************
	*/
void lcdUpdateTime(RTCTimeDate* time) {
    char buffer[17];
    
    // Первая строка: дата
    lcdSetCursor(0, 0);
    sprintf(buffer, "%02d/%02d/%04d% 02d", 
            time->day, time->month, time->year, time->weekday);
    lcdPrintString(buffer);
    
    // Вторая строка: время
    lcdSetCursor(1, 0);
    sprintf(buffer, "%02d:%02d:%02d", 
            time->hours, time->minutes, time->seconds);
    lcdPrintString(buffer);
}
