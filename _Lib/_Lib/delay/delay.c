/**
	******************************************************************************
	* @file		delay.c
	* @brief	Реализация функций задержек
	******************************************************************************
	*/

#include "delay.h"

#define CYCLES_PER_US (SystemCoreClock / 1000000)	// Количество тактов в 1мкС
#define CYCLES_PER_MS (SystemCoreClock / 1000)		// Количество тактов в 1мС

#ifdef DWT_DELAY_ENABLE
/**
	******************************************************************************
	*			Реализация задержек на основе модуля DWT (Data Watchpoint and Trace)
	******************************************************************************
	* @brief	Инициализация DWT
	* @param	None
	* @retval None
	*/
void DWTDelay_Init() {
	
	// Разрешаем доступ к регистрам трассировки:
	// устанавливаем бит TRCENA в регистре DEMCR
	// (Debug Exception and Monitor Control Register)
	CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
	
	// Обнуляем счетчик тактов (CYCCNT - 32-х битный регистр)
	DWT->CYCCNT = 0;
	
	// Включаем сам счетчик:
	// устанавливаем бит CYCCNTENA в регистре управления DWT
	DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
	
	//SystemCoreClockUpdate();	// Обновляем переменную частоты ядра
}
/**
	******************************************************************************
	* @brief	Функция геттер текущего значения счетчика
	* @param	None
	* @retval Текущее значение счетчика тактов
	*/
uint32_t getDWTCountDelay() {
	return DWT->CYCCNT; // Возвращаем текущее значение счетчика тактов
}
/**
	******************************************************************************
	* @brief	Блокирующая задержка в микросекундах на DWT
	* @param	us	количество микросекунд
	* @retval None
	*/
void delayDWT_us(uint32_t us) {
	
	us *= CYCLES_PER_US;											// Переводим микросекунды в такты
	uint32_t startTick = getDWTCountDelay();	// Сохраняем начальное значение
	
	// Сравниваем разницу между текущим и начальным значением
	// с заданным значением задержки в тактах.
	// Вычитание будет работать корректно даже при переполнении DWT->CYCCNT
	// (благодаря беззнаковой арифметике)
	while((getDWTCountDelay() - startTick) < us);
}

/**
	******************************************************************************
	* @brief	Блокирующая задержка в миллисекундах на DWT
	* @param	ms	количество миллисекунд
	* @retval None
	*/
void delayDWT_ms(uint32_t ms) {
	
	ms *= CYCLES_PER_MS;											// Переводим миллисекунды в такты
	uint32_t startTick = getDWTCountDelay();	// Сохраняем начальное значение
	
	// Сравниваем разницу между текущим и начальным значением
	// с заданным значением задержки в тактах.
	// Вычитание будет работать корректно даже при переполнении DWT->CYCCNT
	// (благодаря беззнаковой арифметике)
	while((getDWTCountDelay() - startTick) < ms);
}

/**
	******************************************************************************
	* @brief	НЕблокирующая проверка задержки в микросекундах на DWT
	* @param	us	количество микросекунд
	* @retval None
	*/
uint8_t delayDWT_nb_us(uint32_t startTick, uint32_t us) {
	
	us *= CYCLES_PER_US;											// Переводим микросекунды в такты
	
	// Сравниваем разницу между текущим и начальным значением
	// с заданным значением задержки в тактах.
	// Вычитание будет работать корректно даже при переполнении DWT->CYCCNT
	// (благодаря беззнаковой арифметике)

	return ((getDWTCountDelay() - startTick) >= us);
}
/**
	******************************************************************************
	* @brief	НЕблокирующая проверка задержки в миллисекундах на DWT
	* @param	ms	количество микросекунд
	* @retval None
	*/
uint8_t delayDWT_nb_ms(uint32_t startTick, uint32_t ms) {
	
	ms *= CYCLES_PER_MS;											// Переводим миллисекуды в такты
	
	// Сравниваем разницу между текущим и начальным значением
	// с заданным значением задержки в тактах.
	// Вычитание будет работать корректно даже при переполнении DWT->CYCCNT
	// (благодаря беззнаковой арифметике)

	return ((getDWTCountDelay() - startTick) >= ms);
}
#endif /* DWT_DELAY_ENABLE */

#ifdef SYSTICK_DELAY_ENABLE
/**
	******************************************************************************
	*			Реализация задержек на основе модуля SysTick
	******************************************************************************
	* @brief	Инициализация SysTick
	* @param	None
	* @retval None
	*/
void SysTickDelay_Init(void) {
	
	// Отключаем SysTick на время настройки
	SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
	
	// Загружаем значение перезагрузки (количество тиков в 1 мС)
	// для 72 МГц RELOAD = CYCLES_PER_MS - 1 = 71999 тиков
	SysTick->LOAD = CYCLES_PER_MS-1;
	
  // Обнуляем текущее значение (сбрасываем счётчик и флаг COUNTFLAG)
	SysTick->VAL =0;
	
	// Настраиваем и включаем SysTick:
	SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk // Источник тактирования:
																							// 1 - AHB (частота ядра)
																							// 0 - AHB/8
								| SysTick_CTRL_TICKINT_Msk		// Разрешение прерывания:
																							// 1 -  при достижении нуля
																							// 0 - запрет
								| SysTick_CTRL_ENABLE_Msk;		// Включение SysTick:
																							// 1 - включен
																							// 0 - выключен
}
/**
	******************************************************************************
	* @brief	Обработчик прерывания SysTick
	* @param	None
	* @retval None
	*/
void SysTick_Handler(void) {
	// Проверяем флаг COUNTFLAG (нужно для очистки флага чтением регистра CTRL)
	if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
		// Увеличиваем countDelay каждую миллисекунду
		countDelay++;
	}
}
/**
	******************************************************************************
	* @brief	Функция геттер текущего значения времени в миллисекундах
	* @param	None
	* @retval Текущее значение времени в миллисекундах
	*/
uint32_t getSysTickCountDelay(void) {
	uint32_t tick1, tick2;
	// Читаем дважды, чтобы убедиться, что значение не изменилось
	// во время чтения (маловероятно, но для надежности)
	do {
		tick1 = countDelay;
		tick2 = countDelay;
	} while (tick1 != tick2);
	return tick1;
}
/**
	******************************************************************************
	* @brief	Блокирующая задержка в миллисекундах на SysTick
	* @param	ms	количество миллисекунд
	* @retval None
	*/
void delaySysTick_ms(uint32_t ms) {
	uint32_t startTick =  getSysTickCountDelay();	// Сохраняем начальное значение времени
	
	// Сравниваем разницу между текущим и начальным значением
	// с заданным значением задержки в миллисекундах.
	// Вычитание будет работать корректно даже при переполнении countTick
	// (благодаря беззнаковой арифметике)
	while((getSysTickCountDelay() - startTick) < ms);
}

/**
	******************************************************************************
	* @brief	НЕБЛОКИРУЮЩАЯ проверка задержки в миллисекундах на SysTick
	* @param	start_tick	время начала задержки
	* @param	ms	длительность задержки в миллисекундах
	* @retval 1 - время задержки истекло
	* @retval	0 - время задержки НЕ истекло
	*/
uint8_t delaySysTick_nb_ms(uint32_t startTick, uint32_t ms) {
	// Сравниваем разницу между текущим и начальным значением
	// с заданным значением задержки в миллисекундах.
	// Вычитание будет работать корректно даже при переполнении countTick
	// (благодаря беззнаковой арифметике)
	return (getSysTickCountDelay() - startTick) >= ms;
}
#endif /* SYSTICK_DELAY_ENABLE */

/**
	******************************************************************************
	*				Простая блокирующая задержка в микросекундах на основе циклов
	******************************************************************************
	* @brief	Простая блокирующая задержка микросекундах на основе циклов
	* @note		Неточная, нужно подбирать эмпирически "n"
	* @param	us	количество микросекунд
	* @retval None
	*/
void delaySimple_us(uint32_t us) {
	uint8_t n = 50;
	for (uint32_t i = 0; i < us; i++) {
		for (volatile uint32_t j = 0; j < CYCLES_PER_US/n; j++) {
			__NOP();
			}
	}
}
